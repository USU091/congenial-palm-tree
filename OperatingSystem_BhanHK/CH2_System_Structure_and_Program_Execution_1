H2. 컴퓨터 시스템 구조

일반적으로 컴퓨터 = CPU+메모리;

#메모리(RAM) : CPU의 작업 공간

#CPU : 컴퓨터에서 기억, 해석, 연산, 제어 4대 주요 기능을 관할하는 장치
	-Registers(메모리보다 빠른 저장공간), mode bit, Interrupt Line이 존재한다.
	
#CPU의 역할 : 
cpu의 역할은 평생 메모리에 올라온 데이터를 인스트럭션해서 처리하고 그 다음걸 메모리에서 인스트럭션해서 처리하는 과정을 계속 반복하게 된다.
cpu는 항상 메모리에 있는 Instruction만 실행한다. 정확하게 메모리에 있는 Instruction 하나가 실행된 후, 다음번에 실행할 Instruction(기계어의 주소값)이 증가하여 다음 인스트럭션을 실행한다.


#인터럽트 라인(Interrupt Line) : 
		Q. 키보드에서 어떤 입력이 들어오거나 디스크에서 데이터를 읽어와야 한다면 읽어온 것을 다 끝냈는지 CPU가 어떻게 알수 있는가 ? 
		A. CPU가 현재 A라는 프로그램을 점유하고 있고, 디스크에서 데이터를 읽어와야 한다면 CPU에서 직접 디스크에 접근하는 것이 아니라 디스크 컨트롤러(device controller)에게 특정 데이터를
			읽어오라고 시키면 디스크는 작업을 마친 후 자신의 local buffer에 작업 내용을 저장한다. 그동안 CPU는 놀지 않고 다음 Instruction을 계속 실행한다. 
			
			BUT!! CPU가 프로그램 수행 중 while문이나 for문 같은 루프문을 만나게 되면 그걸 수행하는 동안은 I/O디바이스나 디스크는 접근하지 않고 계속 수행되기 때문에 CPU가 계속 점유되는 상황이 벌어진다. 그동안 다른 프로그램은 수행할 수 없게될 것이다. 그래서 하드웨어 안에는 타이머라는 하드웨어가 존재한다.
	
#타이머  : 특정 프로그램이 CPU를 독점하는 것을 막기 위해 존재하는 하드웨어이다.
		처음엔 운영체제가 CPU를 점유하고 있는데 사용자 프로그램A, 사용자 프로그램B에 CPU를 넘겨주게 된다. 하지만 넘겨줄 때 타이머에 시간을 세팅해서 넘겨준다.이렇게되면 사용자 프로그램A는 독점적으로 CPU를 계속 쓸 수 있는게 아니라 (보통 1초보다 짧다, 수십~수백 밀리세컨드) 세팅된 시간이 되면 타이머가 CPU에 종료가 됐음을 알리고 인터럽트를 걸게된다. 그렇게 되면 CPU는 계속 Instruction을 실행하다가 종료되고 나면 Interrupt Line을 체크한다. 만약 Interrupt Line에 수행해야될 작업이 들어온게 있다고 확인되면 하던 작업을 멈추고 CPU의 제어권이 사용자 프로그램 A로부터 운영체제로 자동으로 넘어가게 된다. 이렇게 되면 운영체제는 다음 사용자 프로그램B에게 타이머에 세팅해서 CPU제어권을 넘겨준다. 이게 계속 반복된다. 

#모드 빗(Mode bit) : 사용자 프로그램의 잘못되 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치가 필요하기 때문에 존재하는 하드웨어이다. 
					모드 빗을 통해 하드웨어적으로 두 가지 모드의 operation이 지원된다.
					1 사용자모드: 사용자 프로그램 수행 한정된 작업만을 수행한다.(보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행가능한 '특권 명령'으로 규정되어있음)
					0 모니터모드: OS 코드 수행(=커널 모드, 시스템 모드) 자유롭게 작업을 수행할 수 있다. 
					Interrupt나 Exception 발생 시 하드웨어가 mode bit을 0으로 바꾼다. 
					사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 세팅하여 넘긴다.
#Device Controller 
	- I/O device controller 
		해당 I/O 장치유형을 관리하는 일종의 작은 CPU
		제어 정보를 위해 controll register, status register를 가짐
		local buffer를 가짐( 일종의 data register)
			ㄴ디스크, I/O 디바이스 또한 CPU, 메모리처럼 컨트롤러가 존재하여 작업을 하게된다. 이 컨트롤러들(디스크, I/O)은 별도의 작업 공간이 필요한데 이 공간을 local buffer라고 한다.
	- I/O는 실제 device와 local buffer 사이에서 일어남
	- Device controller는 I/O가 끝났을 경우 Interrupt로 CPU에 그 사실을 알림
	
	- ** device driver(장치구동기) : OS코드 중 각 장치별 처리 루틴-> software
	- ** device controller(장치제어기) : 각 장치를 통제하는 일종의 작은 CPU -> hardware
		
#DMA controller(Direct Memory Access ctr) : 직접 메모리를 접근할 수 있는 컨트롤러.
	- 메모리를 CPU , DMA ctr 둘 다 접근할 수 있게된다. 
	Q.DMA ctr이 왜 존재하는가 ?
	A. I/O controller가 너무 자주 Interrupt를 걸기 때문에 CPU는 방해받게 된다. DMA ctr 역할은 
	
	I/O디바이스가 CPU에 인터럽트를 걸어서 CPU가 메모리에 local buffer에 있는 정보를 복사해가도록 시키는게 Overhead가 크므로 이것을 막기 위해서 CPU는 계속 일을 수행하도록 하고,
	중간에 local buffer에 들어오는 내용이 작업이 끝나면 DMA가 직접 local buffer에 있는 내용을 메모리에 복사하는 일을 한다. 그리고 그 작업이 끝나면 CPU한테 Interrupt를 한 번만
	걸어서 CPU가 중간에 너무 잦은 인터럽트를 당하지 않고 Overhead를 작게 만들어서 효율적으로 자원을 관리할 수 있게 해주는 역할을 하는 하드웨어이다. 

#입출력(I/O)의 수행
	- 모든 입출력 명령은 특권 명령이다.
	Q. 사용자 프로그램은 어떻게 I/O를 하는가 ?
		- 시스템콜(system call) :사용자 프로그램은 운영체제에게 I/O 요청한다.(=사용자 프로그램이 운영체제의 커널(함수)를 호출하는 것을 시스템콜이라고 한다.)
		- trap을 사용하여 인터럽트 벡터의 특정 위치로 이동한다.(trap=소프트웨어 인터럽트; 사용자 프로그램에서 I/O 를 요청할 수 없기 때문에 CPU에 trap을 걸게 되면 mode bit이 0으로 바뀐 후
			운영체제가 판단하여 디바이스 컨트롤러에 일을 수행 후 CPU가 작업을 수행하도록 한다. 원래 Interrupt는 하드웨어가 CPU에 인터럽트 거는 것을 의미하지만 트랩은 소프트웨어 인터럽트이다.)
		- 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동한다.
		- 올바른 I/O 요청인지 확인 후 I/O를 수행한다.
		- I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮긴다.



## 현대의 운영체제는 인터럽트에 의해 구동된다. 사용자 프로그램이 계속CPU를 점유해서 사용중이고, 소프트웨어 인터럽트나 하드웨어 인터럽트를 할 때에만 OS가 사용되므로 인터럽트에 의해 구동된다고 볼 수 있다.


#시스템콜(system call) :  사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것. 
						사용자 프로그램이 운영체제 코드를 직접 수행하는 것이 불가능 하기 때문에(ex, I/O device를 사용할때는 OS 커널을 불러와야 함) 사용자 프로그램이 CPU의 
						인터럽트 라인에 세팅하여 CPU 제어권이 OS로 넘어가게 된다. 이후 OS가 부탁받은 일을 처리하게 된다. 

#인터럽트( Interrupt) : 인터럽트 당한 시점의 레지스터와 program counter를 save 한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.
	-Interrupt( 넓은 의미 ) 
			ㄴ Interrupt(하드웨어 인터럽트): 하드웨어가 발생시킨 인터럽트
			ㄴ Trap(소프트웨어 인터럽트) = Exception(프로그램이 오류를 범한 경우), System call(프로그램이 커널 함수를 호출하는 경우)
	- 인터럽트 관련 용어 
			ㄴ인터럽트 벡터 : 해당 인터럽트의 처리 루틴 주소를 가지고 있음 (ex, I/O 인터럽트나 타이머 인터럽트 등 종류가 많은데 각 인터럽트마다 수행해야 하는 코드가(=커널) 다르다.
						그렇기 때문에 각 인터럽트마다 처리해야 될 루틴의 주소를 가진것을 인터럽트 벡터라고 한다. 
			ㄴ인터럽트 처리 루틴(=Interrupt Service Routine, 인터럽트 핸들러) : 해당 인터럽트를 처리하는 커널 함수 
			
			
#프로그램 카운터 : 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다. 
